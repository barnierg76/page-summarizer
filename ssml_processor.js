// SSML Processor for DAISYS API
// Validates and cleans SSML tags generated by LLM

class SSMLProcessor {
    constructor() {
        // No static dictionaries needed - LLM handles pronunciation decisions
    }

    /**
     * Process text with SSML tags for better TTS quality
     * Since LLM now provides SSML tags, this mainly validates and cleans
     * @param {string} text - The text to process
     * @param {string} language - The language ('english' or 'dutch')
     * @param {boolean} enableSSML - Whether to apply SSML processing
     * @returns {string} - Text with validated SSML tags
     */
    processText(text, language = 'english', enableSSML = true) {
        if (!enableSSML || !text) {
            return text;
        }

        let processedText = text;

        // 1. Validate SSML tags
        processedText = this.validateSSMLTags(processedText);

        // 2. Validate phoneme format (spaces between phonemes, @ between words)
        processedText = this.validatePhonemeFormat(processedText);

        // 3. Check for language mixing issues (especially in Dutch)
        if (language === 'dutch') {
            processedText = this.validateLanguageMixing(processedText);
        }

        // 4. Add natural pacing breaks (only if not already present)
        processedText = this.addNaturalPacing(processedText);

        // 5. Clean up any redundant or malformed tags
        processedText = this.cleanupSSML(processedText);

        return processedText;
    }

    /**
     * Validate SSML tags are properly formed
     */
    validateSSMLTags(text) {
        // Ensure all tags are properly closed
        const tagPatterns = [
            // Fix unclosed phoneme tags
            {
                pattern: /<phoneme\s+ph="([^"]+)"([^>]*)(?<!\/|\/>)>/g,
                replace: (match, ph, attrs) => {
                    // Extract the word that should be wrapped
                    const afterTag = text.substring(text.indexOf(match) + match.length);
                    const wordMatch = afterTag.match(/^(\S+)/);
                    if (wordMatch) {
                        return `<phoneme ph="${ph}"${attrs}>${wordMatch[1]}</phoneme>`;
                    }
                    return match;
                }
            },
            // Fix malformed say-as tags
            {
                pattern: /<say-as\s+interpret-as="([^"]+)"([^>]*)(?<!\/|\/>)>/g,
                replace: (match, type, attrs) => {
                    const afterTag = text.substring(text.indexOf(match) + match.length);
                    const contentMatch = afterTag.match(/^([^<]+)/);
                    if (contentMatch) {
                        return `<say-as interpret-as="${type}"${attrs}>${contentMatch[1]}</say-as>`;
                    }
                    return match;
                }
            }
        ];

        let result = text;
        tagPatterns.forEach(({pattern, replace}) => {
            result = result.replace(pattern, replace);
        });

        return result;
    }

    /**
     * Validate phoneme format follows DAISYS requirements
     */
    validatePhonemeFormat(text) {
        return text.replace(/<phoneme\s+ph="([^"]+)"/g, (match, phonemes) => {
            // Ensure spaces between individual phonemes
            let cleaned = phonemes.trim();
            
            // Fix common issues:
            // - Missing spaces between phonemes
            cleaned = cleaned.replace(/([a-zæøɑɒɔəɛɜɪʊʌ])([a-zæøɑɒɔəɛɜɪʊʌ])/gi, '$1 $2');
            
            // - Ensure @ is used between words (not spaces for multi-word)
            // If there are clear word boundaries without @, add them
            cleaned = cleaned.replace(/\s{2,}/g, ' @ ');
            
            // - Remove duplicate spaces
            cleaned = cleaned.replace(/\s+/g, ' ');
            
            // - Ensure @ has spaces around it
            cleaned = cleaned.replace(/@/g, ' @ ').replace(/\s+/g, ' ');
            
            return `<phoneme ph="${cleaned}"`;
        });
    }

    /**
     * Validate language mixing - check for potentially untagged English words in Dutch text
     */
    validateLanguageMixing(text) {
        // Common English PHRASES that appear in Dutch text and need tagging
        // Note: single words like 'computer', 'extreme', 'live' are now Dutch words
        const commonEnglishInDutch = [
            'live-blog', 'live-stream', 'livestream', 'e-mail',
            'check-in', 'check-out', 'check-list',
            // Only hyphenated or clear English phrases
        ];

        // Dutch words that should NOT be tagged as English
        // These international words have been naturalized into Dutch
        const dutchWordsNotEnglish = [
            'extreme', 'live', 'computer', 'hotel', 'sport', 'internet',
            'online', 'offline', 'website', 'update', 'download',
            'email', 'team', 'blog', 'podcast', 'romance', 'service',
            'balance', 'finance', 'chance', 'dance', 'performance',
            'conference', 'influence', 'difference', 'experience'
        ];

        // Common Dutch acronyms that should use phoneme tags
        const dutchAcronyms = ['SNS', 'ASN', 'ING', 'ABN', 'AMRO', 'KLM', 'NS', 'ANWB', 'KPN', 'NPO', 'NOS'];

        // Pattern to detect hyphenated words that might be English compounds
        const hyphenatedPattern = /\b([a-z]+-[a-z]+)\b/gi;

        // Pattern to detect say-as spell-out usage
        const sayAsSpellOutPattern = /<say-as\s+interpret-as="spell-out"[^>]*>([^<]+)<\/say-as>/gi;

        // Check each word and log warnings if potentially untagged
        let warnings = [];
        
        // Check for common English phrases not wrapped in voice tags
        commonEnglishInDutch.forEach(word => {
            const regex = new RegExp(`\\b${word}\\b(?![^<]*<\\/voice>)(?![^<]*<\\/phoneme>)`, 'gi');
            if (regex.test(text)) {
                warnings.push(`Potential untagged English phrase: "${word}"`);
            }
        });

        // Check for Dutch words incorrectly tagged as English
        dutchWordsNotEnglish.forEach(word => {
            const regex = new RegExp(`<voice\\s+language="en"[^>]*>[^<]*\\b${word}\\b[^<]*<\\/voice>`, 'gi');
            if (regex.test(text)) {
                warnings.push(`Dutch word incorrectly tagged as English: "${word}"`);
            }
        });

        // Check for Dutch acronyms using say-as instead of phoneme
        let sayAsMatch;
        while ((sayAsMatch = sayAsSpellOutPattern.exec(text)) !== null) {
            const acronym = sayAsMatch[1];
            if (dutchAcronyms.includes(acronym.toUpperCase())) {
                warnings.push(`Dutch acronym "${acronym}" should use phoneme tag, not say-as spell-out`);
            }
        }

        // Check for untagged Dutch acronyms
        dutchAcronyms.forEach(acronym => {
            const regex = new RegExp(`\\b${acronym}\\b(?![^<]*<\\/phoneme>)`, 'g');
            if (regex.test(text)) {
                warnings.push(`Potential untagged Dutch acronym: "${acronym}"`);
            }
        });

        // Check hyphenated words
        let match;
        while ((match = hyphenatedPattern.exec(text)) !== null) {
            const word = match[1];
            // Check if this hyphenated word is inside voice or phoneme tags
            const position = match.index;
            const beforeText = text.substring(0, position);
            const afterText = text.substring(position + word.length);
            
            const isInVoiceTag = beforeText.includes('<voice') && afterText.includes('</voice>');
            const isInPhonemeTag = beforeText.includes('<phoneme') && afterText.includes('</phoneme>');
            
            if (!isInVoiceTag && !isInPhonemeTag) {
                warnings.push(`Potential untagged hyphenated word: "${word}"`);
            }
        }

        // Log warnings to console for debugging
        if (warnings.length > 0) {
            console.warn('[SSML Validator] Language mixing warnings:', warnings);
        }

        return text;
    }

    /**
     * Add natural pacing breaks between major sections
     */
    addNaturalPacing(text) {
        // Only add breaks if they don't already exist
        
        // Add medium breaks between paragraphs (double newlines) if not present
        if (!text.includes('<break') || !text.includes('\n\n<break')) {
            text = text.replace(/\n\n(?!<break)/g, '\n\n<break strength="medium"/>\n');
        }

        // Add strong breaks before conclusions if not present
        const conclusionPhrases = [
            'In conclusion', 'To summarize', 'To sum up',
            'Tot slot', 'Samengevat', 'Concluderend'
        ];
        
        conclusionPhrases.forEach(phrase => {
            const regex = new RegExp(`(${phrase})(?![^<]*<break)`, 'gi');
            text = text.replace(regex, '<break strength="strong"/>$1');
        });

        return text;
    }

    /**
     * Clean up any redundant or malformed SSML tags
     */
    cleanupSSML(text) {
        // Remove empty tags
        text = text.replace(/<[^>]+>\s*<\/[^>]+>/g, '');

        // Remove duplicate breaks
        text = text.replace(/(<break[^>]*\/>\s*){2,}/g, '$1');

        // Fix nested tags of the same type
        text = text.replace(/<phoneme([^>]*)>(<phoneme[^>]*>.*?<\/phoneme>)<\/phoneme>/g, '$2');
        text = text.replace(/<emphasis([^>]*)>(<emphasis[^>]*>.*?<\/emphasis>)<\/emphasis>/g, '$2');

        // Ensure no SSML tags are broken across lines in a way that breaks them
        text = text.replace(/(<[^>]+)\n([^>]*>)/g, '$1 $2');

        // Remove excessive whitespace while preserving structure
        text = text.replace(/\s+/g, ' ');
        text = text.replace(/\n\s*\n/g, '\n\n');

        return text.trim();
    }

    /**
     * Validate the entire SSML document structure
     */
    validateDocument(text) {
        const errors = [];
        
        // Check for unclosed tags
        const openTags = [];
        const tagRegex = /<(\/?)([\w:]+)([^>]*)>/g;
        let match;
        
        while ((match = tagRegex.exec(text)) !== null) {
            const [, closing, tagName, attrs] = match;
            
            if (!closing && !attrs.includes('/')) {
                openTags.push(tagName);
            } else if (closing) {
                const lastOpen = openTags.pop();
                if (lastOpen !== tagName) {
                    errors.push(`Mismatched tag: expected </${lastOpen}> but found </${tagName}>`);
                }
            }
        }
        
        if (openTags.length > 0) {
            errors.push(`Unclosed tags: ${openTags.join(', ')}`);
        }
        
        return {
            valid: errors.length === 0,
            errors: errors
        };
    }
}

// Export for use in extension
if (typeof module !== 'undefined' && module.exports) {
    module.exports = SSMLProcessor;
}